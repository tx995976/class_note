---
id: "my-id"
---


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [操作系统引论](#操作系统引论)
  - [操作系统的发展过程](#操作系统的发展过程)
  - [操作系统的基本特征](#操作系统的基本特征)
  - [操作系统的运行环境](#操作系统的运行环境)
  - [操作系统的主要功能](#操作系统的主要功能)
  - [系统调用](#系统调用)
- [进程的描述与控制](#进程的描述与控制)
  - [前趋图和程序执行](#前趋图和程序执行)
  - [进程的描述](#进程的描述)
  - [进程控制](#进程控制)
  - [进程通信](#进程通信)
- [处理机调度与死锁](#处理机调度与死锁)
  - [处理机调度概述](#处理机调度概述)
    - [(带权)周转时间](#带权周转时间)
  - [调度算法](#调度算法)
  - [实时调度](#实时调度)
  - [死锁概述](#死锁概述)
  - [预防死锁](#预防死锁)
  - [死锁避免](#死锁避免)
  - [死锁的检测与解除](#死锁的检测与解除)
- [进程同步](#进程同步)
  - [进程同步的概念](#进程同步的概念)
  - [软件同步机制](#软件同步机制)
  - [硬件同步机制](#硬件同步机制)
  - [信号量机制](#信号量机制)
  - [经典进程的同步问题](#经典进程的同步问题)
    - [生产者-消费者问题](#生产者-消费者问题)
    - [读者-写者问题](#读者-写者问题)
    - [关于信号量的讨论](#关于信号量的讨论)
      - [关于PV的操作讨论](#关于pv的操作讨论)
- [存储器管理](#存储器管理)
  - [存储器的层次结构](#存储器的层次结构)
  - [程序的装入和链接](#程序的装入和链接)
  - [对换与覆盖](#对换与覆盖)
  - [连续分配存储管理方式](#连续分配存储管理方式)
    - [动态分区分配算法](#动态分区分配算法)
  - [分页存储管理方式](#分页存储管理方式)
  - [分段存储管理方式](#分段存储管理方式)
    - [页表](#页表)
  - [分段存储管理方式](#分段存储管理方式-1)
- [虚拟存储器](#虚拟存储器)
  - [虚拟存储器](#虚拟存储器-1)
  - [请求分页存储管理方式](#请求分页存储管理方式)
  - [页面置换算法](#页面置换算法)
  - [请求分段存储管理方式](#请求分段存储管理方式)
- [输入/输出系统](#输入输出系统)
  - [I/O系统的功能、模型和接口](#io系统的功能-模型和接口)
  - [i/O设备和设备控制器](#io设备和设备控制器)
  - [中断和中断处理程序](#中断和中断处理程序)
  - [用户层的I/O软件](#用户层的io软件)
  - [缓冲区管理](#缓冲区管理)
  - [磁盘性能概述和磁盘调度](#磁盘性能概述和磁盘调度)
    - [磁盘访问时间](#磁盘访问时间)
    - [早期的磁盘调度算法](#早期的磁盘调度算法)
    - [基于扫描的磁盘调度算法](#基于扫描的磁盘调度算法)
- [文件管理](#文件管理)
  - [文件和文件系统](#文件和文件系统)
  - [文件的逻辑结构](#文件的逻辑结构)
  - [文件目录](#文件目录)

<!-- /code_chunk_output -->

# 操作系统引论

---
## 操作系统的发展过程
---
- 无操作系统的计算机系统
    - 人工操作方式
    > 缺点：
    > - 用户独占全机
    > - CPU等待人工操作

    - 脱机I/O方式
    > 优点：
    > - 减少了CPU的空闲时间
    > - 提高了I/O速度
---
- 单道批处理系统
    @import "1.1.png"

- 多道批处理系统
    @import "1.2.png"

- 分时系统
    @import "1.3.png"
    > 分时系统的特征
    > - **多路性** 允许将多台终端同时连接到一台主机，并分时使用
    > - **独立性** 感觉用户独占主机
    > - **及时性** 用户的请求能在很短时间内获得响应
    > - **交互性** 用户可通过终端与系统进行广泛的人机对话

- 实时系统
    > 实时系统：系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。
    > 最主要的特征：**实时性**
    @import "1.4.png"

---

## 操作系统的基本特征

@import "1.5.png"

> - 并发(Concurrence)
>   正是系统中的程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。
>  1. 并行与并发
>   并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。 

> - 共享(Sharing)
>   一般情况下的共享与操作系统环境下的共享其含义并不完全相同。
> 1. 互斥共享方式
>   系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程(线程)使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，在系统中应建立一种机制，以保证多个进程对这类资源的互斥访问。
> 2. 同时访问方式系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源是磁盘设备。一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件。

> - 虚拟(Virtual)
> 1. 时分复用技术
> (1) 虚拟处理机技术。虽然系统中只有一台处理机，但通过时分复用技术能实现（宏观上）**同时**为多个用户服务，使每个终端用户都认为有一个处理机在专门为他服务
> (2) 虚拟设备技术。利用时分复用技术，将一台物理上的1/0设备虚拟为多台逻辑上的1/0设备，并允许每个用户占用一台逻辑上的1/0设备。这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户“同时＂访问的共享设备，即其在**宏观**上能“同时”为多个用户服务。
> 2. 空分复用技术20世纪初，电信业中就已使用频分复用技术来提高信道的利用率。它是指将一个频率范围比较宽的信道划分成多个频率范围较窄的信道(称为频带)，其中的任何一个频带都仅供一对用户通话。早期的频分复用技术只能将一条物理信道划分为几条到几十条话路，后来又很快发展到成千上万条话路，每条话路供一对用户通话。再后来在计算机中也把空分复用技术用于对存储空间的管理，用以提高存储空间的利用率。

> - 异步(Asynchronis)
> 在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“停停走走”的方式运行。

---

## 操作系统的运行环境

- 冯诺依曼架构

- 硬件支持
@import "1.6.png"

- 操作系统内核
@import "1.7.png"

- 处理机的双重工作模式
@import "1.8.png"

---
> - 特权指令：在内核态下运行的指令
>   - 不仅能访问用户空间，还能访问系统空间。
>   - 如启动外部设备、设置系统时钟、管中断、切换执行状态、I/O指令。
> - 非特权指令：在用户态下运行的指令
>   -  应用程序所使用的都是非特权指令。
>   -  防止应用程序的运行异常对系统造成破坏。
>   -  仅能访问用户空间。
---
@import "1.9.png"

---

- 中断与异常
@import "1.10.png"
@import "1.11.png"

> - 中断和异常处理必做事项
>   - 进入中断或异常时
>       - 需保存处理器状态，方便之后恢复执行
>       - 需准备好在高特权级下进行执行的环境
>       - 需选择合适的异常处理器代码进行执行
>       - 需保证用户态和内核态之间的隔离
>   - 处理时
>       - 需获得关于异常的信息，如系统调用参数、错误原因等
>   - 返回时
>       - 需恢复处理器状态，返回低特权级，继续正常执行流

---

## 操作系统的主要功能

- 处理机管理功能
@import "1.12.png"

---

- 存储器管理功能
@import "1.13.png"

---

- 设备管理功能
@import "1.14.png"

---

- 文件管理功能
@import "1.15.png"

---

- 接口管理功能
@import "1.16.png"

---

- 现代操作系统的新功能
@import "1.17.png"

---

## 系统调用

- 系统调用的基本概念
> - 系统调用目的
>   - 使应用程序可以通过它间接调用OS内核中的相关过程，取得相应的服务。
> - 系统调用**概念**
>   - 应用程序请求OS内核完成某功能时的一种过程调用；
>   - 用户与内核的接口。
> - 与一般过程调用的区别:
>   -  运行在不同的系统状态 内核态或用户态
>   -  状态的转换
>   -  返回问题
>   -  嵌套调用

@import "1.18.png"

- 系统调用的类型
@import "1.19.png"

---

# 进程的描述与控制

---

## 前趋图和程序执行

- 前趋图
@import "2.1.png"

---

- 程序顺序执行
> - 一个较大的程序通常都由若干个程序段组成
>   程序在执行时，必须按照某种先后次序逐个执行，仅当前一操作执行完后，才能执行后继操作

- 程序并发执行
@import "2.2.png"

> - 程序并发执行的特征
> - 间断性
>   - 并发程序之间相互制约。
>   - 执行——暂停执行——执行。
> - 失去封闭性
>   - 多个程序共享全机资源。
>   - 执行状态受外界因素影响。
> - 不可再现性
>   - 程序经过多次执行后，虽然其执行时的环境和初始条件都相同，但得到的结果却各不相同。例：两个循环程序共享一个变量

---

## 进程的描述

- 进程的定义和特征
> - 几种典型定义
>   - 进程是程序的一次执行。
>   - 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
>   - 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

> - 进程定义:
>   - 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

> - 进程控制块(process control block, PCB) 
>   - 专门的数据结构，与进程一一对应。

> - 进程的特征:
    @import "2.3.png"

---

- 进程的基本状态与转换

@import "2.4.png"
@import "2.5.png"
@import "2.6.png"

---

- 挂起操作和进程状态的转换

> 1. 挂起操作的引入
> - 引入挂起操作的原因，是基于系统和用户的如下需要：
>   - 终端用户的需要。
>   - 父进程请求。
>   - 负荷调节的需要。
>   - 操作系统的需要。

@import "2.7.png"

---

- 操作系统中用于管理控制的数据结构 **进程控制块(PCB)**
@import "2.8.png"

> PCB的**作用**：
> -  **作为独立运行基本单位的标志；**
> -  **能实现间断性运行方式；**
> -  **提供进程管理所需要的信息；**
> -  **提供进程调度所需要的信息；**
> -  **实现与其他进程的同步与通信。**

> - PCB的**信息**
    @import "2.9.png"
    @import "2.10.png"
    @import "2.11.png"
    @import "2.12.png"

> - PCB的组织方式
    @import "2.13.png"
    @import "2.14.png"
    @import "2.15.png"

---

## 进程控制

---

- [ ] 进程创建
    @import "2.16.png"
    @import "2.17.png"

---

- [ ] 进程终止
    @import "2.18.png"

---

- [ ] 进程的阻塞与唤醒
    @import "2.19.png"

---

- [ ] 进程的挂起与激活
    @import "2.20.png"

---

## 进程通信

> 进程通信是指进程之间的信息交换
    @import "2.21.png"
    @import "2.22.png"

---

- 进程通信的类型
    @import "2.23.png"
    @import "2.24.png"
    @import "2.25.png"

---

- 消息传递通信的实现方式
    @import "2.26.png"
    @import "2.27.png"

---

- Linux进程通信方式

---
---

# 处理机调度与死锁

---

## 处理机调度概述

- 处理机调度层次

> - **高级调度**
>   调度对象：作业
>   根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为它们创建进程和分配必要的资源。然后，将新创建的进程排在就绪队列上等待调度。
>   - 主要用于多道批处理系统中

> - **中级调度**
>   内存调度，将暂不运行的进程，调至外存等待
>   将处于外存上的急需运行的进程，调入内存运行

> - **低级调度**
>   调度对象：进程
>   根据某种调度算法，决定就绪队列中的哪个进程应获得处理机
>   应用在于多道批处理、分时和实时OS

---

- 作业和作业调度
    @import "2.28.png"

---

- 进程调度
    @import "2.29.png"
    @import "2.30.png"

---

- 处理机调度算法的目标
    @import "2.31.png"

### (带权)周转时间

@import "2.32.png"
@import "2.33.png"

> - 评价指标
> - **响应时间**：
>   - 从用户通过键盘提交请求开始，直到系统首次显示出处理结果为止的一段时间
> - **等待时间（进程调度）**：
>   - 进程在就绪队列中等待调度的所有时间之和。

---

## 调度算法

- 先来先服务调度算法(FCFS)
    @import "2.34.png"

---

- 短作业优先（SJF）调度算法
    @import "2.35.png"
    @import "2.36.png"

---

- 优先级调度算法PR
    @import "2.37.png"
    @import "2.38.png"
    @import "2.39.png"
    @import "2.40.png"
    @import "2.41.png"

---

- 时间片轮转(RR)调度算法
    @import "2.42.png"
    @import "2.43.png"

---

## 实时调度

> - 实时调度是针对实时任务的调度
> - 实时任务，都联系着一个截止时间
>   - 硬实时**HRT**任务  
>   - 软实时**SRT**任务  
> - 实时调度应具备一定的条件

---

- 实现实时调度的基本条件
    @import "3.1.png"
    @import "3.2.png"
    @import "3.3.png"

---

- 实时调度算法分类
    @import "3.4.png"
    @import "3.5.png"

---

- 最早截止时间优先(EDF)调度算法
    @import "3.6.png"
    @import "3.7.png"

---

## 死锁概述

> **死锁**（Deadlock）：指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，这些进程都将永远不能再向前推进。

---

- 资源问题
    @import "3.8.png"
    @import "3.9.png"

---

- 死锁原因
    @import "3.10.png"
    @import "3.11.png"
    @import "3.12.png"
    @import "3.13.png"

---

- 死锁定义,必要条件,处理方法
> **死锁**：一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源

---

@import "3.14.png"

---

@import "3.15.png"
@import "3.16.png"

---

## 预防死锁

---
@import "3.17.png"
@import "3.18.png"

---

## 死锁避免
> - 设一个简单而有效的模型，要求每一个进程声明它所需要的资源的最大数。
> - **死锁避免算法**动态检查资源分配状态以确保不会出现循环等待的情况。
> - 资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量。

---

- 安全状态
@import "3.19.png"
@import "3.20.png"

---

@import "3.21.png"

---

- 银行家算法
@import "3.22.png"
@import "3.23.png"
@import "3.24.png"
@import "3.25.png"

---
@import "3.26.png"

---

- 资源分配图
@import "3.27.png"
@import "3.28.png"

---
- 无死锁
@import "3.29.png"
- 有死锁
@import "3.30.png"

> **如果图没有环**，那么不会有死锁！
> **如果图有环**，那么：
>   - 如果每一种资源类型只有一个实例，那么死锁发生；
>   - 如果一种资源类型有多个实例，那么可能死锁

---

## 死锁的检测与解除

---
@import "3.31.png"

---
- 资源分配图的简化
    @import "3.32.png"
    @import "3.33.png"

---

- 死锁检测
    @import "3.34.png"
    @import "3.35.png"

---

- 死锁解除
    @import "3.36.png"
    @import "3.37.png"

---
---

# 进程同步

## 进程同步的概念

- 进程同步的概念引入
    @import "4.1.png"

---

- 临界区
    @import "4.2.png"
    @import "4.3.png"

---

- 解决临界区问题
    @import "4.4.png"

---

## 软件同步机制

- 软件同步机制-Peterson解决方案
    @import "4.5.png"

---

## 硬件同步机制
@import "4.6.png"
@import "4.7.png"
@import "4.8.png"

> - 缺点：
>   - 不符合“让权等待”原则，浪费CPU时间
>   - 很难解决复杂的同步问题

---

## 信号量机制

- 信号量机制介绍
    @import "4.9.png"

---

- 整型信号量
    @import "4.10.png"

---

- 记录型信号量
    @import "4.11.png"
    @import "4.12.png"

---

- AND型信号量
    @import "4.13.png"
    @import "4.14.png"

---

- 信号量集
    @import "4.15.png"

---

- 信号量的应用
    - 利用信号量实现进程互斥
        @import "4.16.png"
    - 利用信号量实现前趋关系
        @import "4.17.png"
    - 利用信号量实现进程同步
        @import "4.18.png"

---

## 经典进程的同步问题

---

### 生产者-消费者问题
@import "4.19.png"
@import "4.20.png"

- 利用信号量
@import "4.21.png"
@import "4.22.png"

---

- 利用AND信号量
    @import "4.23.png"

---

### 读者-写者问题

@import "4.24.png"

---

- 读者优先
@import "4.25.png"
@import "4.26.png"

    - 信号量实现互斥
    @import "4.27.png"
    @import "4.28.png"
    > 其中`rmutex` 为`readcount`的互斥锁

---

- 写者优先
@import "4.30.png"
@import "4.31.png"

---

### 关于信号量的讨论
@import "4.32.png"
@import "4.33.png"

---

- 互斥分析
@import "4.34.png"

---

- 同步分析
@import "4.35.png"

---

#### 关于PV的操作讨论
@import "4.36.png"

---

- 信号量同步的缺点
@import "4.37.png"

---

# 存储器管理
---

## 存储器的层次结构
@import "5.1.png"
@import "5.2.png"
@import "5.3.png"

---

## 程序的装入和链接
---

- 地址绑定和内存保护
@import "5.4.png"
@import "5.5.png"

---

- 程序的装入
@import "5.6.png"

---

- 程序的链接
@import "5.7.png"

---

## 对换与覆盖
---

- 多道程序环境下的对换技术
@import "5.11.png"
@import "5.8.png"
@import "5.9.png"

---

- 对换区的管理
@import "5.10.png"

---

- 进程的换出与换入
@import "5.12.png"
@import "5.13.png"

---

- 覆盖
@import "5.14.png"

---

## 连续分配存储管理方式
@import "5.15.png"

---

- 单一连续分配
@import "5.16.png"

---

- 固定分区分配
@import "5.17.png"

---
- 动态分区分配
@import "5.18.png"
@import "5.19.png"
@import "5.20.png"

---
### 动态分区分配算法
@import "5.21.png"

- 顺序搜索
@import "5.22.png"
@import "5.23.png"
@import "5.24.png"

---

- 索引搜索
@import "5.25.png"
@import "5.26.png"
@import "5.27.png"

---

- 内存分配流程
@import "5.28.png"

---

- 内存回收
@import "5.29.png"
@import "5.30.png"

---

- 动态可重定位分区分配
@import "5.31.png"
@import "5.32.png"

---

## 分页存储管理方式

---

- 分页存储管理
@import "5.33.png"

---

- 地址结构
@import "5.34.png"
@import "5.35.png"

---

## 分段存储管理方式

---


### 页表
@import "5.36.png"
@import "5.37.png"

---

- 地址变换机构
@import "5.38.png"
@import "5.39.png"

---

- 引入快表后的有效访问时间
@import "5.40.png"

---

- 页表结构
@import "5.41.png"

---

- 两级页表
@import "5.42.png"
@import "5.43.png"

---

- 多级页表
@import "5.44.png"

---

- 反置页表
@import "5.45.png"
@import "5.46.png"

---

## 分段存储管理方式

---
- 分段存储管理方式的引入
@import "5.47.png"

---
- 分段的基本原理
@import "5.48.png"

---
- 段表
@import "5.49.png"
@import "5.50.png"

---
- 信息共享
@import "5.51.png"
@import "5.52.png"
@import "5.53.png"

---

- 段页式存储管理方式
@import "5.54.png"
@import "5.55.png"
@import "5.56.png"
@import "5.57.png"


---
---
# 虚拟存储器

## 虚拟存储器
---

- 虚拟存储器概述

@import "6.1.png"
@import "6.2.png"

- 虚拟存储器的定义与特征
@import "6.3.png"
@import "6.4.png"

- 虚拟存储器的实现方法
@import "6.5.png"

---
## 请求分页存储管理方式

- 请求分页中的硬件支持
@import "6.6.png"
@import "6.7.png"
@import "6.8.png"

---
- 请求分页中的内存分配
@import "6.9.png"

---
- 页面调入策略
@import "6.10.png"
@import "6.11.png"
@import "6.12.png"
@import "6.13.png"

---
## 页面置换算法
@import "6.14.png"

--------------------------------
- 最佳置换算法OPT
@import "6.15.png"

---
- 先进先出置换算法(FIFA)
@import "6.16.png"

---
- 最近最少使用算法
@import "6.17.png"
@import "6.18.png"
@import "6.19.png"

---
- 最少使用置换算法
@import "6.20.png"

---
- Clock置换算法
@import "6.21.png"
@import "6.22.png"

---
- 页面缓冲算法
@import "6.23.png"

---
- 访问内存的有效时间
@import "6.24.png"

---
## 请求分段存储管理方式
---

- 请求分段中的硬件支持
@import "6.25.png"
@import "6.26.png"
@import "6.27.png"

---
- 分段的共享和保护
@import "6.28.png"
@import "6.29.png"

---

# 输入/输出系统
---

## I/O系统的功能、模型和接口
@import "7.1.png"

--------------------------------
-  I/O系统的基本功能
@import "7.2.png"

> 1. 隐藏物理设备的细节
> I/O设备的类型非常多，且彼此间在多方面都有差异，诸如它们接收和产生数据的速度，传输方向、粒度、数据的表示形式及可靠性等方面。
> 2. 与设备的无关性
> 隐藏物理设备的细节，在早期的OS中就已实现，它可方便用户对设备的使用。与设备的无关性是在较晚时才实现的，这是在隐藏物理设备细节的基础上实现的。
> 3. 提高处理机和I/O设备的利用率
> 在一般的系统中，许多I/O设备间是相互独立的，能够并行操作，在处理机与设备之间也能并行操作。因此，I/O系统的第三个功能是要尽可能地让处理机和I/O设备并行操作，以提高它们的利用率。为此，一方面要求处理机能快速响应用户的I/O请求，使I/O设备尽快地运行起来；另一方面也应尽量减少在每个I/O设备运行时处理机的干预时间。  
> 4. 对I/O设备进行控制
>    - 对I/O设备进行控制是驱动程序的功能。目前对I/O设备有四种控制方式：
>       - 采用轮询的可编程I/O方式
>       - 采用中断的可编程I/O方式
>       - 直接存储器访问方式
>       - I/O通道方式。
> 5. 确保对设备的正确共享
>    - 从设备的共享属性上，可将系统中的设备分为如下两类：
>      - **独占设备**，进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程后，便由该进程独占，直至用完释放。典型的独占设备有打印机、磁带机等。系统在对独占设备进行分配时，还应考虑到分配的安全性。
>      - **共享设备**，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正确性。
> 6. 错误处理
> 大多数的设备都包括了较多的机械和电气部分，运行时容易出现错误和故障。从处理的角度，可将错误分为临时性错误和持久性错误。对于临时性错误，可通过重试操作来纠正，只有在发生了持久性错误时，才需要向上层报告。

---
- I/O软件的层次结构
@import "7.3.png"
@import "7.4.png"
@import "7.5.png"

---
- I/O系统接口
@import "7.6.png"
@import "7.7.png"
@import "7.8.png"

---

## i/O设备和设备控制器

---

- I/O设备

@import "7.9.png"

------------------------------------------------

@import "7.10.png"

---

- 设备控制器

@import "7.11.png"
@import "7.12.png"
@import "7.13.png"

---

- 内存映像I/O

@import "7.14.png"
@import "7.15.png"

---

- I/O通道

@import "7.16.png"
@import "7.17.png"

**“瓶颈”问题**
> **通道不足，造成“瓶颈”现象**
>  - 通道价格昂贵  

>**解决办法**：
> - 增加设备到CPU间的通路而不增加通道
> - 多通路方式不仅解决了“瓶颈”问题，而且提高了系统的可靠性

---

@import "7.18.png"
@import "7.19.png"

---

- I/O设备的控制方式

@import "7.20.png"
@import "7.21.png"
@import "7.22.png"
@import "7.23.png"

---

## 中断和中断处理程序

---

- 中断简介

@import "7.24.png"

---

- 中断处理程序

@import "7.25.png"
@import "7.26.png"

---

## 用户层的I/O软件

---------------

- 系统调用与库函数

@import "7.27.png"

---

- 假脱机系统

@import "7.28.png"
@import "7.29.png"
@import "7.30.png"
@import "7.31.png"

>  - **SPOOLing系统的特点**
>    - 提高了I/O的速度
>    - 将独占设备改造为共享设备
>    - 实现了虚拟设备功能

- 假脱机打印机系统

@import "7.32.png"

---

## 缓冲区管理

---

> 现代操作系统中，几乎所有的I/O设备在与CPU交换数据时，都用了缓冲区
> **缓冲区是一个存储区域**，可以由专门的硬件组成；**更多的是利用内存**
> 缓冲管理的主要功能是组织好这些缓冲区，并提供获得和释放缓冲区的手段

---

- 缓冲的引入

@import "7.33.png"

---

- 单缓冲和双缓冲

@import "7.34.png"
@import "7.35.png"
@import "7.36.png"
@import "7.37.png"

---

- 环形缓冲区

> - 当输入与输出若两者的速度相差悬殊，双缓冲的效果则不够理想，不过可以随着缓冲区数量的增加，使情况有所改善。
> - **引入多缓冲机制，可将多个缓冲组织为循环缓冲。**

---

@import "7.38.png"
@import "7.39.png"
@import "7.40.png"

---

- 缓冲池

@import "7.41.png"
@import "7.42.png"

---

- 缓存

@import "7.43.png"

---

## 磁盘性能概述和磁盘调度

---

- 磁盘性能简述

@import "7.44.png"
@import "7.45.png"
@import "7.46.png"
@import "7.47.png"

---

### 磁盘访问时间

@import "7.48.png"
@import "7.49.png"
@import "7.50.png"
@import "7.51.png"
@import "7.52.png"

---

### 早期的磁盘调度算法
- 先来先服务FCFS

@import "7.53.png"
@import "7.54.png"

---

- 最短寻道时间优先SSTF
  
@import "7.55.png"
@import "7.56.png"

---

### 基于扫描的磁盘调度算法

@import "7.57.png"
@import "7.58.png"
@import "7.59.png"
@import "7.60.png"
@import "7.61.png"
@import "7.62.png"

---
---

# 文件管理

---

## 文件和文件系统

> 文件系统的管理功能是将其管理的程序和数据通过组织为一系列文件的方式实现的。而文件则是指具有文件名的若干相关元素的集合。元素通常是记录，而记录又是一组有意义的数据项的集合。可见，基于文件系统的概念，可以把数据组成分为**数据项**、**记录**和**文件**三级。

--------------------------------

- 数据项、记录和文件

@import "8.1.png"
@import "8.2.png"
@import "8.3.png"

---

- 文件类型

@import "8.4.png"
@import "8.5.png"

---

- 文件系统的层次结构

@import "8.6.png"
@import "8.7.png"

---

- 文件操作

@import "8.8.png"

---

## 文件的逻辑结构

---

- 文件结构

@import "8.9.png"
@import "8.10.png"

---

- 顺序文件

@import "8.11.png"
@import "8.12.png"
@import "8.13.png"

---

- 顺序文件记录寻址

@import "8.14.png"

---

- 索引文件

@import "8.15.png"
@import "8.16.png"

---

- 索引顺序文件

@import "8.17.png"
@import "8.18.png"
@import "8.19.png"
@import "8.20.png"

---

- 直接文件和哈希文件

@import "8.21.png"

---

## 文件目录
@import "8.22.png"

---

- 文件控制块和索引结点

@import "8.23.png"
@import "8.24.png"
@import "8.25.png"

---

- 简单的目录结构

> - 目录结构的组织，是设计好文件系统的重要环节
>   - 关系到文件系统的存取速度
>   - 也关系到文件的共享性和安全性

> **目录结构和文件都驻留在磁盘上**。

@import "8.26.png"
@import "8.27.png"

---

- 树形结构目录

@import "8.28.png"

---

- 无环图目录

@import "8.29.png"

---

- 目录操作

@import "8.30.png"
@import "8.31.png"

---

- 目录查询技术

@import "8.32.png"

---